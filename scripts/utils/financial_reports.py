"""
SP-API Financial Reports Module
Handles settlement reports, FBA fee estimates, and reimbursement reports.

Settlement reports are auto-generated by Amazon every ~2 weeks.
We LIST existing reports and DOWNLOAD them (not create-poll-download).

FBA fee estimates and reimbursements use the standard create-poll-download pattern.
"""

import os
import gzip
import csv
import io
import time
import hashlib
import requests
from typing import Dict, List, Optional, Any
from datetime import date, datetime, timedelta

from utils.inventory_reports import (
    ENDPOINTS, MARKETPLACE_IDS, get_endpoint,
    poll_report_status, download_report
)


import re


def _safe_get(row: dict, key: str, default: str = "") -> str:
    """Safely get a string value from a row dict, handling None values."""
    val = row.get(key, default)
    if val is None:
        return default
    return str(val).strip()


def _normalize_date(val: str) -> Optional[str]:
    """
    Normalize date strings from settlement reports to ISO format.

    Amazon settlement reports use inconsistent date formats:
    - "2025-12-27 23:20:10 UTC" (ISO-like, works in PostgreSQL)
    - "25.12.2025 17:49:21 UTC" (European DD.MM.YYYY, fails in PostgreSQL)
    - "22.01.2026 17:49:21 UTC" (European DD.MM.YYYY, fails)

    Returns ISO format: "2025-12-25 17:49:21" or None
    """
    if not val:
        return None

    # Match DD.MM.YYYY HH:MM:SS (with optional timezone)
    match = re.match(r'^(\d{2})\.(\d{2})\.(\d{4})\s+(\d{2}:\d{2}:\d{2})', val)
    if match:
        day, month, year, time_part = match.groups()
        return f"{year}-{month}-{day} {time_part}"

    # Match DD.MM.YYYY (date only)
    match = re.match(r'^(\d{2})\.(\d{2})\.(\d{4})$', val)
    if match:
        day, month, year = match.groups()
        return f"{year}-{month}-{day}"

    # Already ISO-compatible — strip timezone suffix if present
    val = val.replace(" UTC", "").replace(" PST", "").replace(" PDT", "")
    return val


# Financial report types
FINANCIAL_REPORT_TYPES = {
    "SETTLEMENT": "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE_V2",
    "REIMBURSEMENTS": "GET_FBA_REIMBURSEMENTS_DATA",
    "FBA_FEE_ESTIMATES": "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA",
}

# Map Amazon's marketplace-name field → our marketplace code
# Used to determine correct marketplace_id per settlement row
MARKETPLACE_NAME_TO_CODE = {
    "Amazon.com": "USA",
    "Amazon.ca": "CA",
    "Amazon.com.mx": "MX",
    "Non-Amazon US": "USA",  # Non-Amazon channel, still US
    "Amazon.co.uk": "UK",
    "Amazon.de": "DE",
    "Amazon.fr": "FR",
    "Amazon.it": "IT",
    "Amazon.es": "ES",
    "Amazon.ae": "UAE",
    "Amazon.com.au": "AU",
    "Amazon.co.jp": "JP",
}

# Fallback: currency → marketplace code (for rows with no marketplace-name)
CURRENCY_TO_MARKETPLACE_CODE = {
    "USD": "USA",
    "CAD": "CA",
    "MXN": "MX",
    "GBP": "UK",
    "EUR": "DE",  # Default EUR to DE (most common)
    "AED": "UAE",
    "AUD": "AU",
    "JPY": "JP",
}


# =============================================================================
# Settlement Reports (LIST → DOWNLOAD pattern)
# =============================================================================

def list_settlement_reports(
    access_token: str,
    marketplace_code: str,
    region: str = "NA",
    created_since: str = None,
    max_results: int = 100
) -> List[Dict]:
    """
    List available settlement reports for a marketplace.

    Amazon auto-generates settlement reports every ~2 weeks.
    This lists all available ones, optionally filtered by date.

    Args:
        access_token: Valid SP-API access token
        marketplace_code: Marketplace code (e.g., 'USA')
        region: API region
        created_since: ISO date string to filter (e.g., '2024-01-01T00:00:00Z')
        max_results: Maximum reports to return (max 100)

    Returns:
        List of report metadata dicts with reportId, reportDocumentId, etc.
    """
    marketplace_info = MARKETPLACE_IDS.get(marketplace_code.upper())
    if not marketplace_info:
        raise ValueError(f"Invalid marketplace code: {marketplace_code}")

    endpoint = get_endpoint(region)
    url = f"https://{endpoint}/reports/2021-06-30/reports"

    params = {
        "reportTypes": FINANCIAL_REPORT_TYPES["SETTLEMENT"],
        "marketplaceIds": marketplace_info["id"],
        "pageSize": min(max_results, 100)
    }

    if created_since:
        # Ensure ISO format with timezone
        if "T" not in created_since:
            created_since = f"{created_since}T00:00:00Z"
        params["createdSince"] = created_since

    all_reports = []
    next_token = None

    while True:
        if next_token:
            params["nextToken"] = next_token

        response = requests.get(
            url,
            params=params,
            headers={"x-amz-access-token": access_token}
        )
        response.raise_for_status()
        data = response.json()

        reports = data.get("reports", [])
        all_reports.extend(reports)

        next_token = data.get("nextToken")
        if not next_token or len(all_reports) >= max_results:
            break

        # Rate limit for getReports
        time.sleep(1)

    # Filter to only DONE reports
    done_reports = [r for r in all_reports if r.get("processingStatus") == "DONE"]

    print(f"✓ Found {len(done_reports)} settlement reports for {marketplace_code}")

    return done_reports


def download_settlement_report(
    access_token: str,
    report_document_id: str,
    region: str = "NA"
) -> List[Dict[str, Any]]:
    """
    Download and parse a settlement report (TSV format).

    Settlement reports have a special structure:
    - First row(s) may contain settlement-level header info
    - Subsequent rows are individual transactions

    Returns:
        List of dictionaries, one per row
    """
    # Reuse the generic download_report function from inventory_reports
    return download_report(access_token, report_document_id, region)


def compute_settlement_row_hash(row: Dict[str, str]) -> str:
    """
    Compute an MD5 hash for a settlement transaction row for dedup.

    Since Amazon doesn't provide a row-level unique ID, we hash
    key fields to create one.
    """
    hash_fields = [
        row.get("settlement-id", "") or "",
        row.get("transaction-type", "") or "",
        row.get("order-id", "") or "",
        row.get("sku", "") or "",
        row.get("amount-type", "") or "",
        row.get("amount-description", "") or "",
        row.get("amount", "") or "",
        row.get("posted-date-time", "") or "",
        row.get("order-item-code", "") or "",
        row.get("adjustment-id", "") or "",
        row.get("promotion-id", "") or "",
    ]
    hash_string = "|".join(hash_fields)
    return hashlib.md5(hash_string.encode()).hexdigest()


def _resolve_marketplace_id(
    row: Dict[str, str],
    marketplace_uuids: Dict[str, str],
    fallback_marketplace_id: str
) -> str:
    """
    Determine the correct marketplace UUID for a settlement row.

    Priority:
    1. marketplace-name field (e.g., "Amazon.com" → USA)
    2. currency field as fallback (e.g., "CAD" → CA)
    3. fallback_marketplace_id (passed by caller)
    """
    # Try marketplace-name first
    mp_name = _safe_get(row, "marketplace-name")
    if mp_name and mp_name in MARKETPLACE_NAME_TO_CODE:
        code = MARKETPLACE_NAME_TO_CODE[mp_name]
        if code in marketplace_uuids:
            return marketplace_uuids[code]

    # Try currency as fallback
    currency = _safe_get(row, "currency")
    if currency and currency in CURRENCY_TO_MARKETPLACE_CODE:
        code = CURRENCY_TO_MARKETPLACE_CODE[currency]
        if code in marketplace_uuids:
            return marketplace_uuids[code]

    return fallback_marketplace_id


def parse_settlement_rows(
    rows: List[Dict[str, str]],
    marketplace_id: str,
    import_id: str = None,
    marketplace_uuids: Dict[str, str] = None,
    filter_marketplace_code: str = None
) -> tuple:
    """
    Parse settlement report rows into transactions and summary.

    Each row's marketplace is determined from its marketplace-name field,
    NOT from the caller's marketplace parameter (which is only a fallback).

    Amazon's LIST API returns ALL NA-region settlements regardless of
    marketplace filter, so a single report may contain transactions for
    USA, CA, and MX.

    Args:
        rows: Raw TSV rows from download_report()
        marketplace_id: Fallback Supabase marketplace UUID
        import_id: Data import tracking ID
        marketplace_uuids: Dict mapping marketplace codes to UUIDs
                           (e.g., {"USA": "f47ac10b-...", "CA": "a1b2c3d4-..."})
                           If provided, marketplace_id is resolved per-row.
        filter_marketplace_code: If set, only include rows matching this marketplace
                                 (e.g., "USA"). Rows for other marketplaces are skipped.

    Returns:
        (transactions_list, summary_dict)
    """
    transactions = []
    summary = None
    skipped_other_marketplace = 0

    for row in rows:
        settlement_id = _safe_get(row, "settlement-id")
        if not settlement_id:
            continue

        # Determine marketplace_id per-row
        if marketplace_uuids:
            row_marketplace_id = _resolve_marketplace_id(
                row, marketplace_uuids, marketplace_id
            )
        else:
            row_marketplace_id = marketplace_id

        # Filter by marketplace if requested
        if filter_marketplace_code and marketplace_uuids:
            target_mp_id = marketplace_uuids.get(filter_marketplace_code)
            if target_mp_id and row_marketplace_id != target_mp_id:
                skipped_other_marketplace += 1
                continue

        # Parse amount
        amount_str = _safe_get(row, "amount")
        amount = None
        if amount_str:
            try:
                amount = float(amount_str)
            except (ValueError, TypeError):
                pass

        # Parse quantity
        qty_str = _safe_get(row, "quantity-purchased")
        quantity = None
        if qty_str:
            try:
                quantity = int(qty_str)
            except (ValueError, TypeError):
                pass

        # Parse posted-date-time (normalize European date format)
        posted_dt = _normalize_date(_safe_get(row, "posted-date-time"))

        # Compute row hash for dedup
        row_hash = compute_settlement_row_hash(row)

        transaction = {
            "marketplace_id": row_marketplace_id,
            "settlement_id": settlement_id,
            "settlement_start_date": _normalize_date(_safe_get(row, "settlement-start-date")),
            "settlement_end_date": _normalize_date(_safe_get(row, "settlement-end-date")),
            "deposit_date": _normalize_date(_safe_get(row, "deposit-date")),
            "transaction_type": _safe_get(row, "transaction-type") or None,
            "order_id": _safe_get(row, "order-id") or None,
            "merchant_order_id": _safe_get(row, "merchant-order-id") or None,
            "adjustment_id": _safe_get(row, "adjustment-id") or None,
            "shipment_id": _safe_get(row, "shipment-id") or None,
            "marketplace_name": _safe_get(row, "marketplace-name") or None,
            "sku": _safe_get(row, "sku") or None,
            "quantity_purchased": quantity,
            "amount_type": _safe_get(row, "amount-type") or None,
            "amount_description": _safe_get(row, "amount-description") or None,
            "amount": amount,
            "currency_code": _safe_get(row, "currency") or None,
            "fulfillment_id": _safe_get(row, "fulfillment-id") or None,
            "posted_date": _normalize_date(_safe_get(row, "posted-date")),
            "posted_date_time": posted_dt,
            "order_item_code": _safe_get(row, "order-item-code") or None,
            "merchant_order_item_id": _safe_get(row, "merchant-order-item-id") or None,
            "merchant_adjustment_item_id": _safe_get(row, "merchant-adjustment-item-id") or None,
            "promotion_id": _safe_get(row, "promotion-id") or None,
            "row_hash": row_hash,
            "import_id": import_id,
        }

        transactions.append(transaction)

        # Build summary from first row of this settlement
        if summary is None and settlement_id:
            total_amount_str = _safe_get(row, "total-amount")
            total_amount = None
            if total_amount_str:
                try:
                    total_amount = float(total_amount_str)
                except (ValueError, TypeError):
                    pass

            summary = {
                "marketplace_id": row_marketplace_id,
                "settlement_id": settlement_id,
                "settlement_start_date": _normalize_date(_safe_get(row, "settlement-start-date")),
                "settlement_end_date": _normalize_date(_safe_get(row, "settlement-end-date")),
                "deposit_date": _normalize_date(_safe_get(row, "deposit-date")),
                "total_amount": total_amount,
                "currency_code": _safe_get(row, "currency") or None,
                "transaction_count": 0,  # Will be updated
                "import_id": import_id,
            }

    if skipped_other_marketplace > 0:
        print(f"    Skipped {skipped_other_marketplace} rows belonging to other marketplaces")

    # Update transaction count in summary
    if summary:
        summary["transaction_count"] = len(transactions)

    return transactions, summary


# =============================================================================
# Reimbursement Reports (CREATE → POLL → DOWNLOAD)
# =============================================================================

def create_reimbursement_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA",
    start_date: date = None,
    end_date: date = None
) -> str:
    """
    Create a reimbursement report request.

    Args:
        access_token: Valid SP-API access token
        marketplace_code: Marketplace code
        region: API region
        start_date: Start of date range (default: 60 days ago)
        end_date: End of date range (default: today)

    Returns:
        Report ID string
    """
    marketplace_info = MARKETPLACE_IDS.get(marketplace_code.upper())
    if not marketplace_info:
        raise ValueError(f"Invalid marketplace code: {marketplace_code}")

    endpoint = get_endpoint(region)
    amazon_marketplace_id = marketplace_info["id"]

    if not start_date:
        start_date = date.today() - timedelta(days=60)
    if not end_date:
        end_date = date.today()

    url = f"https://{endpoint}/reports/2021-06-30/reports"

    payload = {
        "reportType": FINANCIAL_REPORT_TYPES["REIMBURSEMENTS"],
        "marketplaceIds": [amazon_marketplace_id],
        "dataStartTime": start_date.strftime("%Y-%m-%dT00:00:00Z"),
        "dataEndTime": end_date.strftime("%Y-%m-%dT23:59:59Z")
    }

    response = requests.post(
        url,
        json=payload,
        headers={
            "x-amz-access-token": access_token,
            "Content-Type": "application/json"
        }
    )

    response.raise_for_status()
    data = response.json()
    report_id = data["reportId"]

    print(f"✓ Created reimbursement report {report_id} for {marketplace_code} ({start_date} to {end_date})")

    return report_id


def pull_reimbursement_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA",
    start_date: date = None,
    end_date: date = None
) -> List[Dict[str, Any]]:
    """
    High-level: create, poll, and download a reimbursement report.
    """
    report_id = create_reimbursement_report(
        access_token, marketplace_code, region, start_date, end_date
    )

    result = poll_report_status(access_token, report_id, region)

    rows = download_report(access_token, result["reportDocumentId"], region)

    return rows


# =============================================================================
# FBA Fee Estimates Report (CREATE → POLL → DOWNLOAD)
# =============================================================================

def create_fba_fee_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA"
) -> str:
    """
    Create an FBA fee estimates report.

    This report requires:
    - dataStartTime: At least 72 hours prior to now
    - dataEndTime: Current time

    Can only be requested once per day per seller.

    Returns:
        Report ID string
    """
    marketplace_info = MARKETPLACE_IDS.get(marketplace_code.upper())
    if not marketplace_info:
        raise ValueError(f"Invalid marketplace code: {marketplace_code}")

    endpoint = get_endpoint(region)
    amazon_marketplace_id = marketplace_info["id"]

    # Must be at least 72 hours back
    start_time = datetime.utcnow() - timedelta(hours=76)  # 76hrs for safety margin
    end_time = datetime.utcnow()

    url = f"https://{endpoint}/reports/2021-06-30/reports"

    payload = {
        "reportType": FINANCIAL_REPORT_TYPES["FBA_FEE_ESTIMATES"],
        "marketplaceIds": [amazon_marketplace_id],
        "dataStartTime": start_time.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "dataEndTime": end_time.strftime("%Y-%m-%dT%H:%M:%SZ")
    }

    response = requests.post(
        url,
        json=payload,
        headers={
            "x-amz-access-token": access_token,
            "Content-Type": "application/json"
        }
    )

    response.raise_for_status()
    data = response.json()
    report_id = data["reportId"]

    print(f"✓ Created FBA fee estimates report {report_id} for {marketplace_code}")

    return report_id


def pull_fba_fee_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA"
) -> List[Dict[str, Any]]:
    """
    High-level: create, poll, and download FBA fee estimates report.
    """
    report_id = create_fba_fee_report(access_token, marketplace_code, region)

    result = poll_report_status(access_token, report_id, region)

    rows = download_report(access_token, result["reportDocumentId"], region)

    return rows
