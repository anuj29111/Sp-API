"""
SP-API Financial Reports Module
Handles settlement reports, FBA fee estimates, and reimbursement reports.

Settlement reports are auto-generated by Amazon every ~2 weeks.
We LIST existing reports and DOWNLOAD them (not create-poll-download).

FBA fee estimates and reimbursements use the standard create-poll-download pattern.
"""

import os
import gzip
import csv
import io
import time
import hashlib
import requests
from typing import Dict, List, Optional, Any
from datetime import date, datetime, timedelta

from utils.inventory_reports import (
    ENDPOINTS, MARKETPLACE_IDS, get_endpoint,
    poll_report_status, download_report
)


# Financial report types
FINANCIAL_REPORT_TYPES = {
    "SETTLEMENT": "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE_V2",
    "REIMBURSEMENTS": "GET_FBA_REIMBURSEMENTS_DATA",
    "FBA_FEE_ESTIMATES": "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA",
}


# =============================================================================
# Settlement Reports (LIST → DOWNLOAD pattern)
# =============================================================================

def list_settlement_reports(
    access_token: str,
    marketplace_code: str,
    region: str = "NA",
    created_since: str = None,
    max_results: int = 100
) -> List[Dict]:
    """
    List available settlement reports for a marketplace.

    Amazon auto-generates settlement reports every ~2 weeks.
    This lists all available ones, optionally filtered by date.

    Args:
        access_token: Valid SP-API access token
        marketplace_code: Marketplace code (e.g., 'USA')
        region: API region
        created_since: ISO date string to filter (e.g., '2024-01-01T00:00:00Z')
        max_results: Maximum reports to return (max 100)

    Returns:
        List of report metadata dicts with reportId, reportDocumentId, etc.
    """
    marketplace_info = MARKETPLACE_IDS.get(marketplace_code.upper())
    if not marketplace_info:
        raise ValueError(f"Invalid marketplace code: {marketplace_code}")

    endpoint = get_endpoint(region)
    url = f"https://{endpoint}/reports/2021-06-30/reports"

    params = {
        "reportTypes": FINANCIAL_REPORT_TYPES["SETTLEMENT"],
        "marketplaceIds": marketplace_info["id"],
        "pageSize": min(max_results, 100)
    }

    if created_since:
        # Ensure ISO format with timezone
        if "T" not in created_since:
            created_since = f"{created_since}T00:00:00Z"
        params["createdSince"] = created_since

    all_reports = []
    next_token = None

    while True:
        if next_token:
            params["nextToken"] = next_token

        response = requests.get(
            url,
            params=params,
            headers={"x-amz-access-token": access_token}
        )
        response.raise_for_status()
        data = response.json()

        reports = data.get("reports", [])
        all_reports.extend(reports)

        next_token = data.get("nextToken")
        if not next_token or len(all_reports) >= max_results:
            break

        # Rate limit for getReports
        time.sleep(1)

    # Filter to only DONE reports
    done_reports = [r for r in all_reports if r.get("processingStatus") == "DONE"]

    print(f"✓ Found {len(done_reports)} settlement reports for {marketplace_code}")

    return done_reports


def download_settlement_report(
    access_token: str,
    report_document_id: str,
    region: str = "NA"
) -> List[Dict[str, Any]]:
    """
    Download and parse a settlement report (TSV format).

    Settlement reports have a special structure:
    - First row(s) may contain settlement-level header info
    - Subsequent rows are individual transactions

    Returns:
        List of dictionaries, one per row
    """
    # Reuse the generic download_report function from inventory_reports
    return download_report(access_token, report_document_id, region)


def compute_settlement_row_hash(row: Dict[str, str]) -> str:
    """
    Compute an MD5 hash for a settlement transaction row for dedup.

    Since Amazon doesn't provide a row-level unique ID, we hash
    key fields to create one.
    """
    hash_fields = [
        row.get("settlement-id", "") or "",
        row.get("transaction-type", "") or "",
        row.get("order-id", "") or "",
        row.get("sku", "") or "",
        row.get("amount-type", "") or "",
        row.get("amount-description", "") or "",
        row.get("amount", "") or "",
        row.get("posted-date-time", "") or "",
        row.get("order-item-code", "") or "",
        row.get("adjustment-id", "") or "",
        row.get("promotion-id", "") or "",
    ]
    hash_string = "|".join(hash_fields)
    return hashlib.md5(hash_string.encode()).hexdigest()


def parse_settlement_rows(
    rows: List[Dict[str, str]],
    marketplace_id: str,
    import_id: str = None
) -> tuple:
    """
    Parse settlement report rows into transactions and summary.

    Args:
        rows: Raw TSV rows from download_report()
        marketplace_id: Supabase marketplace UUID
        import_id: Data import tracking ID

    Returns:
        (transactions_list, summary_dict)
    """
    transactions = []
    summary = None

    for row in rows:
        settlement_id = row.get("settlement-id", "").strip()
        if not settlement_id:
            continue

        # Parse amount
        amount_str = row.get("amount", "").strip()
        amount = None
        if amount_str:
            try:
                amount = float(amount_str)
            except (ValueError, TypeError):
                pass

        # Parse quantity
        qty_str = row.get("quantity-purchased", "").strip()
        quantity = None
        if qty_str:
            try:
                quantity = int(qty_str)
            except (ValueError, TypeError):
                pass

        # Parse posted-date-time
        posted_dt = row.get("posted-date-time", "").strip() or None

        # Compute row hash for dedup
        row_hash = compute_settlement_row_hash(row)

        transaction = {
            "marketplace_id": marketplace_id,
            "settlement_id": settlement_id,
            "settlement_start_date": row.get("settlement-start-date", "").strip() or None,
            "settlement_end_date": row.get("settlement-end-date", "").strip() or None,
            "deposit_date": row.get("deposit-date", "").strip() or None,
            "transaction_type": row.get("transaction-type", "").strip() or None,
            "order_id": row.get("order-id", "").strip() or None,
            "merchant_order_id": row.get("merchant-order-id", "").strip() or None,
            "adjustment_id": row.get("adjustment-id", "").strip() or None,
            "shipment_id": row.get("shipment-id", "").strip() or None,
            "marketplace_name": row.get("marketplace-name", "").strip() or None,
            "sku": row.get("sku", "").strip() or None,
            "quantity_purchased": quantity,
            "amount_type": row.get("amount-type", "").strip() or None,
            "amount_description": row.get("amount-description", "").strip() or None,
            "amount": amount,
            "currency_code": row.get("currency", "").strip() or None,
            "fulfillment_id": row.get("fulfillment-id", "").strip() or None,
            "posted_date": row.get("posted-date", "").strip() or None,
            "posted_date_time": posted_dt,
            "order_item_code": row.get("order-item-code", "").strip() or None,
            "merchant_order_item_id": row.get("merchant-order-item-id", "").strip() or None,
            "merchant_adjustment_item_id": row.get("merchant-adjustment-item-id", "").strip() or None,
            "promotion_id": row.get("promotion-id", "").strip() or None,
            "row_hash": row_hash,
            "import_id": import_id,
        }

        transactions.append(transaction)

        # Build summary from first row of this settlement
        if summary is None and settlement_id:
            total_amount_str = row.get("total-amount", "").strip()
            total_amount = None
            if total_amount_str:
                try:
                    total_amount = float(total_amount_str)
                except (ValueError, TypeError):
                    pass

            summary = {
                "marketplace_id": marketplace_id,
                "settlement_id": settlement_id,
                "settlement_start_date": row.get("settlement-start-date", "").strip() or None,
                "settlement_end_date": row.get("settlement-end-date", "").strip() or None,
                "deposit_date": row.get("deposit-date", "").strip() or None,
                "total_amount": total_amount,
                "currency_code": row.get("currency", "").strip() or None,
                "transaction_count": 0,  # Will be updated
                "import_id": import_id,
            }

    # Update transaction count in summary
    if summary:
        summary["transaction_count"] = len(transactions)

    return transactions, summary


# =============================================================================
# Reimbursement Reports (CREATE → POLL → DOWNLOAD)
# =============================================================================

def create_reimbursement_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA",
    start_date: date = None,
    end_date: date = None
) -> str:
    """
    Create a reimbursement report request.

    Args:
        access_token: Valid SP-API access token
        marketplace_code: Marketplace code
        region: API region
        start_date: Start of date range (default: 60 days ago)
        end_date: End of date range (default: today)

    Returns:
        Report ID string
    """
    marketplace_info = MARKETPLACE_IDS.get(marketplace_code.upper())
    if not marketplace_info:
        raise ValueError(f"Invalid marketplace code: {marketplace_code}")

    endpoint = get_endpoint(region)
    amazon_marketplace_id = marketplace_info["id"]

    if not start_date:
        start_date = date.today() - timedelta(days=60)
    if not end_date:
        end_date = date.today()

    url = f"https://{endpoint}/reports/2021-06-30/reports"

    payload = {
        "reportType": FINANCIAL_REPORT_TYPES["REIMBURSEMENTS"],
        "marketplaceIds": [amazon_marketplace_id],
        "dataStartTime": start_date.strftime("%Y-%m-%dT00:00:00Z"),
        "dataEndTime": end_date.strftime("%Y-%m-%dT23:59:59Z")
    }

    response = requests.post(
        url,
        json=payload,
        headers={
            "x-amz-access-token": access_token,
            "Content-Type": "application/json"
        }
    )

    response.raise_for_status()
    data = response.json()
    report_id = data["reportId"]

    print(f"✓ Created reimbursement report {report_id} for {marketplace_code} ({start_date} to {end_date})")

    return report_id


def pull_reimbursement_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA",
    start_date: date = None,
    end_date: date = None
) -> List[Dict[str, Any]]:
    """
    High-level: create, poll, and download a reimbursement report.
    """
    report_id = create_reimbursement_report(
        access_token, marketplace_code, region, start_date, end_date
    )

    result = poll_report_status(access_token, report_id, region)

    rows = download_report(access_token, result["reportDocumentId"], region)

    return rows


# =============================================================================
# FBA Fee Estimates Report (CREATE → POLL → DOWNLOAD)
# =============================================================================

def create_fba_fee_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA"
) -> str:
    """
    Create an FBA fee estimates report.

    This report requires:
    - dataStartTime: At least 72 hours prior to now
    - dataEndTime: Current time

    Can only be requested once per day per seller.

    Returns:
        Report ID string
    """
    marketplace_info = MARKETPLACE_IDS.get(marketplace_code.upper())
    if not marketplace_info:
        raise ValueError(f"Invalid marketplace code: {marketplace_code}")

    endpoint = get_endpoint(region)
    amazon_marketplace_id = marketplace_info["id"]

    # Must be at least 72 hours back
    start_time = datetime.utcnow() - timedelta(hours=76)  # 76hrs for safety margin
    end_time = datetime.utcnow()

    url = f"https://{endpoint}/reports/2021-06-30/reports"

    payload = {
        "reportType": FINANCIAL_REPORT_TYPES["FBA_FEE_ESTIMATES"],
        "marketplaceIds": [amazon_marketplace_id],
        "dataStartTime": start_time.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "dataEndTime": end_time.strftime("%Y-%m-%dT%H:%M:%SZ")
    }

    response = requests.post(
        url,
        json=payload,
        headers={
            "x-amz-access-token": access_token,
            "Content-Type": "application/json"
        }
    )

    response.raise_for_status()
    data = response.json()
    report_id = data["reportId"]

    print(f"✓ Created FBA fee estimates report {report_id} for {marketplace_code}")

    return report_id


def pull_fba_fee_report(
    access_token: str,
    marketplace_code: str,
    region: str = "NA"
) -> List[Dict[str, Any]]:
    """
    High-level: create, poll, and download FBA fee estimates report.
    """
    report_id = create_fba_fee_report(access_token, marketplace_code, region)

    result = poll_report_status(access_token, report_id, region)

    rows = download_report(access_token, result["reportDocumentId"], region)

    return rows
